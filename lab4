#include "stdafx.h"
#include <iostream>
#include <math.h>

using namespace std;

class Complex // класс комплексных чисел  
{
	double re, im; // целая и мнимая части  

				   // создаем конструкторы   
public:

	double get_re()
	{
		return re;
	}

	double get_im()
	{
		return im;
	}

	Complex() {};

	Complex(double r) // конструктор по умолчанию  
	{
		re = r;
		im = 0;
	}

	Complex(double r, double i) // конструктор по умолчанию  
	{
		re = r;
		im = i;
	}

	Complex(Complex &c) // конструктор копирования  
	{
		re = c.re;
		im = c.im;
	}

	~Complex() {}

	float abs() // Модуль комплексного числа  
	{
		return sqrt(re * re - im * im);
	}

	Complex & operator = (Complex &c) // перегрузка оператора присваивания  
	{
		re = c.re;
		im = c.im;

		return (*this);
	}

	Complex Complex::operator + (Complex &c) // перегрузка оператора сложения  
	{
		Complex temp;

		temp.re = re + c.re;
		temp.im = im + c.im;

		return temp;
	}


	Complex Complex::operator * (Complex &c) // перегрузка оператора умножения
	{
		Complex temp;

		temp.re = re*c.re;
		temp.im = re*c.im;

		return temp;
	}

};

class matrix {
	Complex** T;
	int M;
	int N;
public:
	matrix(int m, int n) : T(NULL), M(m), N(n)
	{
		T = new Complex*[M]; //строки в массиве
		for (int i = 0; i < M; i++)
		{
			T[i] = new Complex[N]; //  столбцы
			for (int j = 0; j < N; j++)
				T[i][j] = Complex(0,0);
		}
	}
	Complex& operator () (int i, int j)
	{
		return T[i][j];
	}

	friend matrix operator+(matrix& s1, matrix& s2);
	friend matrix operator*(matrix& s1, matrix& s2);

		void print()
	{
		for (int i = 0; i < M; i++)
		{
			for (int j = 0; j < N; j++)
			cout << T[i][j].get_re() << ", " << T[i][j].get_im() <<" | ";
			cout << endl;
		}
		cout << endl;
	}
	~matrix()
	{

	}

};

matrix operator+(matrix& s1, matrix& s2)
{
	matrix q(s1.M, s1.N);
	for (int i = 0; i < s1.N; i++)
	{
		for (int j = 0; j < s1.M; j++)
		{
			q(i, j) = s2(i, j) + s1(i, j);
		}
	}
	return q;
}

/*matrix operator*(matrix& s1, matrix& s2)
{
	matrix q(s1.M, s1.N);
	for (int i = 0; i < s1.N; i++)
	{
		for (int j = 0; j < s1.M; j++)
		{
			q(i, j) = (s2(i, j) * s1(i, j)) + ( s2(i,j) * s1(i+1,j));
		}
	}
	return q;
}*/

int main()
{
	Complex value1(5, 2);
	Complex value2(3, -3);

	matrix A(2, 2);
	A(0, 0) = Complex(1, 0);
	A(0, 1) = Complex(2, 1);
	A(1, 0) = Complex(0, 0);
	A(1, 1) = Complex(3, 4);

	matrix B(2, 2);
	B(0, 0) = Complex(1, 0);
	B(0, 1) = Complex(3, 2);
	B(1, 0) = Complex(1, 2);
	B(1, 1) = Complex(0, 0);
	
	
	A.print();
	B.print();
	matrix C(2, 2);
	C = A + B;
	C.print();
	matrix D(2, 2);
	D = A * B;
	D.print();

	cout << value1.get_re() << endl;
	cout << value1.get_im() << endl;
	cout << value2.get_re() << endl;
	cout << value2.get_im() << endl;

	system("pause");
	return 0;
}


